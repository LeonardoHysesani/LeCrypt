THIS CIPHER WAS DEVELOPED AND IMPLEMENTED BY LEONARDO HYSESANI

THE π CIPHER EXPLAINED
__________________________________________________
GENERALLY
__________________________________________________
A starting pointer is set (pointing  to a certain pi digit, the first digit of our subsequent pointer value),
length of pointer value (how many digits it spans),
length of the character shift's value (how many digits it spans),
distance (D) between pointer and shift value's (N) first digit.

__________________________________________________
SPECIFICALLY
__________________________________________________
• An initial pointer is given for the starting point (positive integer).
• Specify what length the subsequent/self-generated initial pointer values will have.
• Length of the character shift value is given (named 'N' below).
• Specify how many positions after the pointer will N begin. (called 'D' or distance between their first digits).
• The pointer value is set to the π's decimal values that follow the one that it is pointing to and keeps repeating.
• The N decimal points that are D positions after the pointer are used for the current character's shift (if D > 25 then the shift is D MOD 26 ( 26 is the length of the alphabet in use) ).
• After the last character is shifted, the current index is used as the next message's initial index.
This means that the only index that needs to be shared is the one that encrypts the first message.
All subsequent ones are self generated.
This gives us the advantage that the shift value is literally unpredictable as opposed to the conventional
keywords or character shift values which usually repeat or even if they don't, they can likely be guessed.

Inputs:
1. Initial pointer
2. Pointers' length
3. Character shift value's length
4. Distance between pointer and shift value
5. Message to be encrypted


Implementation tips:
1. A lot (maybe millions) of π digits will be loaded on the main memory (RAM) but only the ones that come after the pointer are needed.
So clearing the previous digits will drastically improve the algorithm's performance. (1Mb ~ 1 million digits)
2. Store the digits as unsigned ints (1 byte) or some other small size data type to further improve performance.